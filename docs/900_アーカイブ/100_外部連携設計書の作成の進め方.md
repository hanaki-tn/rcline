# 外部連携設計書の作成の進め方

## 背景
### AIへの依頼内容
ClaudeCodeを使って開発を進めています。
画面周りは問題なく進んでいますが、LINEとの連携部分でつまずくことが多いです。
これは、クラウドコード自体がLINE連携用のAPI仕様を知らないため、任せきりにできないのが理由だと考えています。

そこで今回、公式LINEのシステムにおける「LINE連携部分」をすべて洗い出し、それぞれについて仕様を整理したいと思います。
仕様の確認には、LINEの公式情報やGitHubに公開されている公式サンプルを参照します。最終的には設計書としてまとめる予定です。

そのために、まず設計書の「項目（段落）」を列挙してほしいです。

### AIからの回答
```
いいですね、その進め方が一番事故りにくいです。まずは“LINE連携に関わるところだけ”を設計書として独立させましょう。下記の章立てなら、Claude Codeにもそのまま渡しやすく、あとから詳細を肉付けできます。

# 公式LINE連携 設計書（章立て案）

1. 目的／適用範囲

   * 本設計書のゴール（どの機能までを対象にするか）
   * 対象システム・対象環境（本番/VPS、ローカル、ステージング）

2. 用語・ID定義

   * Channel ID／Channel Secret／Access Token（短期/長期）
   * LINE User ID、Room ID、Group ID
   * LIFF ID、LIFFアプリ種別
   * Audience ID（narrowcast/自動絞り込み）

3. 全体アーキテクチャ

   * 連携フロー図：ユーザー → LIFF → APIサーバー → LINE API
   * Webhookの流れと役割分担（認証・業務ロジック・DB書込）
   * 構成要素（APIサーバー、LIFF静的配信、DB、ジョブ／キュー等）

4. 認証・認可（Messaging API / LIFF / OpenID Connect）

   * Access Tokenの取得・更新戦略（長期化／ローテーション）
   * Webhook署名検証（X-Line-Signature）
   * LIFFログイン（スコープ、nonce、state管理）、プロフィール取得
   * OpenID ConnectでのIDトークン検証（必要なら）

5. Webhook設計（方針）
   ※詳細は 133_Webhookハンドラ設計.md を参照

   * エンドポイント定義（URL、メソッド、CORS、CSP方針）
   * 受信イベント一覧とハンドリング方針

     * follow / unfollow / join / leave
     * message（text、image、file など対応可否）
     * postback / beacon / memberJoined 他
   * 冪等性（イベントIDの重複排除）、再試行対策、タイムアウト方針
   * 障害時のフェイルセーフ（ロギング、アラート）

6. メッセージ送信設計

   * replyMessage（制約、使用ポリシー）
   * pushMessage（どのユースケースで使うか）
   * multicast / narrowcast（オーディエンスの作り方・更新タイミング）
   * broadcast（使う/使わないの基準）
   * 速度制限・同報設計（バッチ分割、バックオフ、レート制御）

7. メッセージ内容仕様

   * テキスト、スタンプ、画像、位置情報
   * テンプレートメッセージ（確認/ボタン/カルーセル）
   * Flex Message（レイアウト方針、共通コンポーネント、バージョン管理）
   * Quick Reply（導線設計）
   * 日本語絵文字・機種依存文字の扱い

8. リッチメニュー／友だち管理

   * リッチメニュー構成・切替（ユーザー属性や状態による出し分け）
   * 友だち追加（follow）時の初期メッセージ設計
   * ブロック（unfollow）時の扱い（DB更新・集計）

9. アカウント連携・会員紐づけ（重要）

   * LINE User ID と内部会員IDの対応ルール
   * linkToken を用いた明示的連携フロー
   * “サイレント自動紐づけ”の仕様（前提・安全策・例外処理）
   * 代理回答や未登録者ハンドリング（暫定ID・後追い統合）

10. イベント・出欠ユースケース設計（本プロジェクト固有）

    * 出欠依頼メッセージ配信（対象抽出、予約送信）
    * 回答画面（LIFF）→ 投稿（WebhookまたはAPI）→ 集計反映
    * 代理回答、回答期限、リマインド方針
    * エラー／未完了時のフォローアップ

11. OA Manager／Audience 運用（使う場合）

    * テスト配信（自分だけ／小グループ）の手順
    * Audience の作成・更新・命名規則
    * OA Manager とAPI送信の役割分担

12. エラーハンドリング／リトライ／レート制限

    * LINE APIのHTTPステータス別対処（400/401/429/5xx）
    * 再試行ポリシー（指数バックオフ、最大回数）
    * 送信失敗時のキューリカバリ、部分成功の扱い

13. ログ／監視／追跡性

    * 送受信ログ（payloadのどこまで残すか、PIIマスク）
    * 主要メトリクス（配信数、到達/失敗、Webhook遅延）
    * アラート閾値・通知経路（Slack/メール など）

14. セキュリティ／プライバシー

    * 秘密情報の保護（環境変数、権限分離）
    * 署名検証／CSRF対策／クリックジャッキング対策（LIFF/CSP）
    * 個人情報の最小保持・削除ポリシー
    * 監査ログ／アクセス制御

15. テスト戦略

    * ローカル開発（モックWebhooks、トンネリング、固定レスポンス）
    * ステージングでの結合テスト（実機テスト手順）
    * リグレッション（テンプレ/Flexのスナップショット）
    * 負荷・レート制限を意識したリハーサル

16. 運用手順／権限管理

    * Channel切替/ローテーション手順（事故防止のチェックリスト）
    * 配信前チェック（対象数、テンプレ検証、誤送信防止）
    * 障害対応フロー（一次切り分け→回復→事後レビュー）

17. パフォーマンス・スケーリング

    * キューイング戦略（大量配信の分割・スケジュール）
    * DBロック/重複送信の防止
    * キャッシュ（プロフィール、オーディエンス）

18. 料金／制約／ポリシー

    * 料金プランの前提とAPI上限
    * 画像サイズ・ファイルサイズ・メッセージ長制限
    * 利用規約に関わるNGユースケース

19. バージョン・依存関係

    * 使用SDK（言語・バージョン）と公式サンプルの参照元
    * メッセージ仕様のバージョン固定／更新手順
    * 互換性リスクの管理（Deprecated APIの監視）

20. リリース／ロールバック手順

    * 機能フラグ／段階的リリース
    * コンテンツ（Flex/テンプレ）差し替え手順
    * ロールバックとデータ巻き戻しの可否・手順

21. 既知の課題・未決事項

    * 例：未登録者の暫定運用、将来の統合方針 など
    * 解消のための検討タスク

22. 付録

    * API→実装マッピング表（エンドポイント・メソッド・責務）
    * 公式ドキュメント／公式GitHubサンプルの参照リスト（空欄でOK：後でURL記入）
    * テンプレ／FlexのJSONスニペット置き場（サンプルと命名規則）
```
