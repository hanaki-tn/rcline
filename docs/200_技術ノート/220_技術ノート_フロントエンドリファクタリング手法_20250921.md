# 技術ノート: フロントエンドリファクタリング手法 - DOM直接操作から状態管理パターンへ

**作成日**: 2025-09-21
**更新日**: 2025-09-21
**対象**: RC公式LINE管理画面 - イベント作成機能
**ステータス**: 実装完了、本番適用可能

## 概要

DOM直接操作によるイベント作成機能を、状態管理パターンに基づく堅牢な実装へリファクタリングした。
本ドキュメントは今後の類似リファクタリングの指針となることを目的とする。

## 問題の背景

### 従来の実装課題
1. **DOM直接操作**: フォーム値の取得・設定が散在
2. **状態の不整合**: DOMとロジックの状態が乖離
3. **初期化問題**: ページロード時の値同期が不完全
4. **エラーハンドリング**: 各所でのエラー処理が不統一
5. **非同期制御**: ローディング状態の管理が不完全

## リファクタリング10のポイント

1. **状態の単一情報源（SSOT）**
   - `eventFormState`にフォーム値を集約（DOMは入出力に限定）
   - UI表示時＝状態→DOM、入力時＝DOM→状態、送信時＝状態→API

2. **DOM同期パターンの確立**
   - `hydrateFromDOM()`で初期化時と送信直前にDOM→状態同期
   - ページロード時の既定値問題を根本解決

3. **非同期処理の制御フラグ管理**
   - `isAudienceLoaded`, `isMembersResolved`, `isSubmitting`で状態制御
   - ローディングゲートシステムによる複合条件管理

4. **二重送信防止の徹底**
   - ボタン無効化＋処理中フラグ＋finally句での確実解除
   - UI即時フィードバック（送信中...表示）

5. **バリデーションの前段統一**
   - 送信直前に`validateEvent(eventFormState)`を一括実行
   - 必須・サイズ・日付整合を中央集約でチェック

6. **エラーハンドリングの統一**
   - `showToast()`による一貫したエラー表示
   - API呼び出し失敗時の適切なフォールバック

7. **画像処理の安全性向上**
   - 5MBサイズ制限の事前チェック
   - ファイル形式バリデーションの実装

8. **型安全性の確保**
   - ID比較時の数値変換による文字列/数値混在対策
   - APIレスポンスの型ゆらぎ対応

9. **ブラウザ互換性対策**
   - BFCache対応によるページ復帰時の状態同期
   - キャッシュバスター管理

10. **UX向上施策**
    - 処理状況の即座フィードバック
    - 読み込み状態の適切な表示制御

### 具体的な問題事例
```javascript
// 問題のあるコード例
function createEvent() {
    const title = document.getElementById('title').value; // DOM直接参照
    if (!title) {
        alert('タイトルは必須です'); // 不統一なエラー表示
        return;
    }
    // バリデーション、送信処理が混在...
}
```

## リファクタリング戦略

### 1. 基本アーキテクチャ設計

#### 状態管理オブジェクト
```javascript
// Single Source of Truth
let eventFormState = {
    title: '',
    body: '',
    imageFile: null,
    held_at: null,
    deadline_at: null,
    audience_id: null,
    extra_text_enabled: false,
    extra_text_label: '備考',
    target_member_ids: [],
};
```

#### 制御フラグ
```javascript
// 非同期処理の制御
let isAudienceLoaded = false;    // audience選択肢の読み込み完了
let isMembersResolved = false;   // 対象メンバーの解決完了
let isSubmitting = false;        // 送信処理中
```

### 2. DOM→State同期パターン

#### ハイドレーション関数
```javascript
function hydrateFromDOM() {
    if (!$(EL.title) || !$(EL.body)) return;

    eventFormState.title = $(EL.title).value?.trim() || '';
    eventFormState.body = $(EL.body).value?.trim() || '';
    eventFormState.imageFile = $(EL.image).files?.[0] ?? null;
    eventFormState.held_at = toJstIsoFromDatetimeLocal($(EL.heldAt).value || '');
    eventFormState.deadline_at = endOfDayJstIsoFromDate($(EL.deadlineAt).value || '');
    eventFormState.audience_id = $(EL.audience).value || null;
    eventFormState.extra_text_enabled = $(EL.chkExtra).checked;
    eventFormState.extra_text_label = $(EL.extraLabel).value?.trim() || '備考';

    // UI状態も同期
    $(EL.extraOpts).classList.toggle('hidden', !eventFormState.extra_text_enabled);
}
```

**適用タイミング**:
- ページ初期化時（DOM Ready）
- フォーム送信直前（最新値の取得）

### 3. 非同期処理制御パターン

#### ローディングゲートシステム
```javascript
function setSubmitButtonEnabled() {
    const btn = $(EL.submitBtn);
    if (!btn) return;

    // 複数条件の論理積で制御
    const canSubmit = isAudienceLoaded && isMembersResolved && !isSubmitting;

    btn.disabled = !canSubmit;
    btn.textContent = isSubmitting ? '送信中…' :
                     !isAudienceLoaded ? '読み込み中…' :
                     'イベント作成＆送信';
}
```

#### 二重送信防止
```javascript
async function createEvent() {
    const btn = $(EL.submitBtn);
    if (!btn || btn.disabled || isSubmitting) return;

    try {
        isSubmitting = true;
        btn.disabled = true;
        setSubmitButtonEnabled(); // 即座にUI更新

        // 処理実行...
    } finally {
        isSubmitting = false;
        setSubmitButtonEnabled();
    }
}
```

### 4. バリデーション統一パターン

#### 中央集約バリデーション
```javascript
function validateEvent(state) {
    const errors = [];

    if (!state.title?.trim()) {
        errors.push('タイトルは必須です');
    }
    if (!state.body?.trim()) {
        errors.push('本文は必須です');
    }
    if (!state.held_at) {
        errors.push('開催日時は必須です');
    }

    // 画像サイズチェック
    if (state.imageFile && state.imageFile.size > 5 * 1024 * 1024) {
        errors.push('画像ファイルは5MB以下にしてください');
    }

    return errors;
}
```

### 5. エラーハンドリング統一パターン

#### トースト通知システム
```javascript
function showToast(message, type = 'info') {
    // 統一されたエラー表示
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);

    // 自動削除
    setTimeout(() => toast.remove(), 3000);
}
```

#### APIエラー処理
```javascript
async function handleApiCall(apiFunc, errorMessage) {
    try {
        const response = await apiFunc();
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('API呼び出しエラー:', error);
        showToast(errorMessage, 'error');
        throw error;
    }
}
```

## 段階的リファクタリング手順

### フェーズ1: 基盤整備
1. 状態オブジェクトの定義
2. 制御フラグの整備
3. ユーティリティ関数の準備

### フェーズ2: 状態同期
1. DOM→State同期関数の実装
2. 初期化処理の整備
3. イベントリスナーの統合

### フェーズ3: 非同期制御
1. ローディング状態管理
2. 二重送信防止
3. エラーハンドリング統一

### フェーズ4: 高度な機能
1. BFCache対策
2. 型安全性向上
3. UX改善（即時フィードバック等）

### フェーズ5: 最終調整
1. エッジケース対応
2. パフォーマンス最適化
3. 総合テスト

## ベストプラクティス

### 1. 状態管理
- **Single Source of Truth**: 状態は一箇所で管理
- **Immutable Update**: 状態更新時は新しいオブジェクトを作成
- **Clear Separation**: DOM操作と状態管理を分離

### 2. 非同期処理
- **Loading Gates**: 複数の非同期処理を制御フラグで管理
- **Error Boundaries**: エラーが他の処理に影響しないよう分離
- **User Feedback**: 処理状況をユーザーに明確に伝える

### 3. バリデーション
- **Early Validation**: 可能な限り早期にバリデーション実行
- **Consistent Messages**: エラーメッセージの統一
- **Progressive Enhancement**: 段階的な機能向上

### 4. エラーハンドリング
- **Graceful Degradation**: エラー時でも最低限の機能は維持
- **Meaningful Messages**: ユーザーが理解できるエラーメッセージ
- **Proper Logging**: 開発者向けの詳細ログ

## パフォーマンス考慮事項

### 1. DOM操作の最適化
```javascript
// 悪い例
function updateUI() {
    document.getElementById('title').value = state.title;
    document.getElementById('body').value = state.body;
    // ... 個別にDOM操作
}

// 良い例
function updateUI() {
    const fragment = document.createDocumentFragment();
    // バッチでDOM操作
    requestAnimationFrame(() => {
        // 必要最小限の更新
    });
}
```

### 2. イベントリスナー管理
```javascript
// 重複登録防止
function setupEventListeners() {
    // 既存リスナーを削除
    $(EL.audience)?.removeEventListener('change', handleAudienceChange);
    // 新しいリスナーを登録
    $(EL.audience)?.addEventListener('change', handleAudienceChange);
}
```

## ブラウザ互換性対策

### 1. BFCache対策
```javascript
window.addEventListener('pageshow', (event) => {
    if (event.persisted) {
        // BFCacheから復帰時の処理
        hydrateFromDOM();
        loadAudiencesForEvents();
    }
});
```

### 2. 型安全性
```javascript
// 文字列/数値の混在に対する対策
const idSet = new Set(memberIds.map(v => Number(v)));
const targetMembers = allMembers.filter(member => idSet.has(Number(member.id)));
```

## テスト戦略

### 1. 基本テストケース
- デフォルト値での送信
- Audience切り替え後の即座送信
- 5MB超画像でのエラー表示

### 2. エッジケースの検証
- ネットワークエラー時の動作
- 認証切れ時の処理
- ブラウザキャッシュ影響の確認

## 今後の改善方向性

### 1. 短期改善
- TypeScriptの導入検討
- 単体テストの整備
- パフォーマンス監視の導入

### 2. 中長期改善
- フレームワーク化の検討（React/Vue等）
- CI/CDパイプラインの整備
- A/Bテスト環境の構築

## 適用可能な他の機能

本リファクタリング手法は以下の機能にも適用可能：

1. **メンバー管理機能**: CSV一括登録、個別編集
2. **配信グループ管理**: グループ作成、メンバー割り当て
3. **イベント編集機能**: 既存イベントの修正
4. **設定画面**: システム設定の変更

## まとめ

DOM直接操作から状態管理パターンへのリファクタリングにより、以下の効果を得られた：

- **保守性向上**: コードの見通しが良くなり、バグ修正が容易に
- **安定性向上**: エラーハンドリングの統一により、予期しない動作を削減
- **UX向上**: 適切なローディング表示と即時フィードバック
- **拡張性向上**: 新機能追加時の影響範囲を限定

この手法を他の機能にも適用することで、システム全体の品質向上が期待できる。

---

**次回適用時の注意点**:
- 既存機能を段階的にリファクタリングし、一度に大きな変更を避ける
- ユーザーテストを早期に実施し、UXの劣化がないことを確認する
- キャッシュ戦略を含めたデプロイ計画を事前に策定する