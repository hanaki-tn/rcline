# 技術ノート: LIFF認証問題の解決と運用改善

**作成日**: 2025-08-30  
**更新日**: 2025-08-30  
**ステータス**: 問題解決済み、要継続改善  

## 問題の概要

LIFF画面で「イベント一覧の読み込みに失敗しました」エラーが発生。HTTP 502 Bad Gatewayが原因。

## 解決までのプロセス

### 1. エラー分析

**クライアント側ログ**:
```
[18:51:58] ERROR: fetch応答: 502
[18:51:58] ERROR: APIエラー詳細: {}
[18:51:58] ERROR: fetch失敗: HTTP 502
```

**調査結果**:
- LIFF認証は正常動作
- アクセストークン取得も成功
- 問題はAPI serverへの接続不可

### 2. 根本原因の特定

**API server稼働状況**:
```bash
docker ps
# STATUS: Restarting (1) 46 seconds ago
```

**API serverログ**:
```
Database connection failed: [Error: SQLITE_CANTOPEN: unable to open database file] {
  errno: 14,
  code: 'SQLITE_CANTOPEN'
}
```

**原因**: `./rcline.db` がファイルではなく**ディレクトリ**になっていた
```bash
ls -la /opt/rcline/rcline.db
# drwxr-xr-x  2 root root 4096  8月 30 15:42 .
```

### 3. Dockerマウントでディレクトリが作成されるメカニズム

**発生シナリオ**:
1. `docker-compose.vps.yml` の設定:
   ```yaml
   volumes:
     - ./rcline.db:/app/data/rcline.db
   ```
2. `./rcline.db` ファイルが存在しない状態でコンテナ起動
3. Dockerが「ファイルが見つからない」と判断
4. **自動的にディレクトリとして `./rcline.db/` を作成**
5. SQLiteが「ファイルではなくディレクトリ」を開こうとしてエラー

### 4. 解決手順

```bash
# 1. コンテナ停止・削除
docker rm -f rcline-api-server-1

# 2. 誤ったディレクトリを削除
rm -rf /opt/rcline/rcline.db

# 3. 正しいデータベースファイルを復元
# （バックアップから復元 - 135168バイト）

# 4. コンテナ再作成
docker compose up -d api-server
```

**結果**: 
- ✅ データベース接続成功
- ✅ LIFF認証成功
- ✅ API通信正常化
- ✅ イベント一覧表示成功

## 運用改善が必要な項目

### A. データベースファイル管理の改善

#### A-1. 予防策の実装
```bash
# VPS環境でのデプロイ前チェック
check_db_file() {
    if [[ ! -f "./rcline.db" ]]; then
        echo "ERROR: rcline.db file not found!"
        echo "Creating empty database file..."
        touch ./rcline.db
        chmod 666 ./rcline.db
    fi
    
    if [[ -d "./rcline.db" ]]; then
        echo "ERROR: rcline.db is a directory, not a file!"
        exit 1
    fi
}
```

#### A-2. ヘルスチェックの追加
```yaml
# docker-compose.vps.yml に追加
api-server:
  # 既存設定...
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:4000/health"]
    interval: 30s
    timeout: 10s
    retries: 3
    start_period: 40s
```

### B. Caddyfile設定の整理

#### B-1. 使用状況調査が必要な設定

**調査コマンド**:
```bash
# アクセスログで実際の使用状況を確認
tail -n 1000 /var/log/caddy/access.log | grep -E "(static|webhook|linehook|^/api)"
```

**整理候補**:
1. `handle_path /static/*` - "optional" とあり使用状況不明
2. `handle /api/*` - 新 `/rcline/api/*` と重複の可能性
3. `handle /linehook/*` - "移行完了まで保持"の状況確認
4. `handle_path /webhook/*` - n8n webhookの利用状況確認
5. `reverse_proxy api-server:4000` - 最後のcatchallの必要性

#### B-2. 推奨Caddyfile構造
```caddy
awf.technavigation.jp {
    # ログ設定（トラブル時調査用）
    log {
        output file /var/log/caddy/access.log
        format console
        level INFO
    }
    
    # セキュリティヘッダー
    header {
        Strict-Transport-Security "max-age=31536000"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
    }
    
    # === 確実に使用されているもの ===
    
    # 画像ファイル公開
    handle_path /files/* {
        root * /var/www/files
        file_server
    }
    
    # RC LINE システム - API
    handle /rcline/api/* {
        uri strip_prefix /rcline
        reverse_proxy api-server:4000
    }
    
    # RC LINE LIFF画面
    handle_path /rcline/* {
        root * /opt/rcline/services/api-server/public
        try_files {path} /index.html
        file_server
        header {
            Content-Security-Policy "default-src 'self' https://awf.technavigation.jp; script-src 'self' https://static.line-scdn.net 'unsafe-inline'; connect-src 'self' https://awf.technavigation.jp https://api.line.me https://access.line.me https://liff.line.me; img-src 'self' data: https://static.line-scdn.net https://profile.line-scdn.net; style-src 'self' 'unsafe-inline' https://static.line-scdn.net; frame-ancestors https://liff.line.me https://awf.technavigation.jp"
        }
    }
    
    # === 使用状況調査後に判断 ===
    
    # Static (要調査)
    # handle_path /static/* {
    #     root * /opt/www
    #     file_server
    # }
    
    # 従来API（要調査）
    # handle /api/* {
    #     reverse_proxy api-server:4000
    # }
    
    # linehook（移行状況要確認）
    # handle /linehook/* {
    #     reverse_proxy linehook:3000
    # }
    
    # n8n webhook（使用状況要確認）
    # handle_path /webhook/* {
    #     reverse_proxy api-server:4000
    # }
    
    # 未定義パスは404（セキュリティ向上）
    respond 404
}
```

### C. データベースバックアップ体制

#### C-1. 定期バックアップの設定
```bash
# crontab設定例
# 毎日2時にバックアップ実行
0 2 * * * cp /opt/rcline/rcline.db /opt/rcline/backups/rcline_$(date +\%Y\%m\%d).db

# 古いバックアップの自動削除（30日以上前）
0 3 * * 0 find /opt/rcline/backups -name "rcline_*.db" -mtime +30 -delete
```

#### C-2. バックアップ前の整合性チェック
```bash
#!/bin/bash
# backup_with_check.sh
DB_FILE="/opt/rcline/rcline.db"
BACKUP_DIR="/opt/rcline/backups"

# SQLiteの整合性チェック
if sqlite3 "$DB_FILE" "PRAGMA integrity_check;" | grep -q "ok"; then
    cp "$DB_FILE" "$BACKUP_DIR/rcline_$(date +%Y%m%d_%H%M).db"
    echo "Backup completed successfully"
else
    echo "Database integrity check failed - backup skipped"
    exit 1
fi
```

### D. ログローテーション設定

#### D-1. Caddyログローテーション
```bash
# /etc/logrotate.d/caddy
/var/log/caddy/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    copytruncate
}
```

### E. 環境依存ファイル管理の改善

#### E-1. 現在の手動管理
```
- docker-compose.vps.yml → docker-compose.yml
- Caddyfile.vps → Caddyfile  
- common.vps.js → common.js
```

#### E-2. 自動化案
```bash
#!/bin/bash
# deploy-env.sh
ENV=${1:-vps}

echo "Deploying $ENV environment..."

# ファイルコピー
cp "docker-compose.$ENV.yml" "docker-compose.yml"
cp "caddy/Caddyfile.$ENV" "caddy/Caddyfile"
cp "services/api-server/public/liff/common.$ENV.js" "services/api-server/public/liff/common.js"

# 権限設定
chmod 644 docker-compose.yml caddy/Caddyfile
chmod 644 services/api-server/public/liff/common.js

echo "Environment files deployed for: $ENV"
```

### F. モニタリング強化

#### F-1. 推奨監視項目
1. **コンテナヘルスチェック**
2. **API応答時間**
3. **データベースファイルサイズ**
4. **ディスク容量**
5. **LIFF認証成功率**

#### F-2. アラート設定例
```bash
# simple_monitor.sh
#!/bin/bash

# API Health Check
if ! curl -sf http://localhost:4000/health > /dev/null; then
    echo "ALERT: API server health check failed"
fi

# Database file check
if [[ -d "/opt/rcline/rcline.db" ]]; then
    echo "ALERT: rcline.db is a directory, not a file!"
fi

# Container status check
if ! docker ps | grep -q "rcline-api-server.*Up"; then
    echo "ALERT: API server container is not running"
fi
```

## アクションアイテム

### 緊急（1週間以内）
- [ ] データベースファイルの定期バックアップ設定
- [ ] Caddyfile使用状況調査の実施
- [ ] ヘルスチェック機能の追加

### 重要（1ヶ月以内）  
- [ ] Caddyfile設定の整理・最適化
- [ ] 環境依存ファイル管理の自動化
- [ ] ログローテーション設定

### 改善（3ヶ月以内）
- [ ] モニタリング・アラート機能の実装
- [ ] デプロイプロセスの標準化
- [ ] 障害対応手順書の作成

## 今回の学び

1. **Dockerボリュームマウントの注意点**: ファイルが存在しない場合、Dockerが自動的にディレクトリを作成する
2. **事前チェックの重要性**: デプロイ前のファイル存在確認が必要
3. **段階的調査の効果**: 認証 → API接続 → データベース の順序立てた調査により効率的に問題を特定
4. **運用フェーズでの改善**: 問題解決後の予防策実装が重要

## 参考情報

- [Docker Compose volumes documentation](https://docs.docker.com/compose/compose-file/compose-file-v3/#volumes)
- [SQLite integrity check](https://www.sqlite.org/pragma.html#pragma_integrity_check)
- [Caddy reverse proxy](https://caddyserver.com/docs/caddyfile/directives/reverse_proxy)