# 技術ノート: DB初期化問題と対策
作成日: 2025-08-25

## 1. 現象

### 1.1 発生日時と状況
- **発生日時**: 2025-08-25 18:44頃（DBファイル作成時刻から推定）
- **発見時刻**: 2025-08-25 19:00頃（管理画面ログイン失敗時）
- **発生環境**: VPS本番環境（/opt/rcline）

### 1.2 具体的な症状
```
【症状1】管理画面ログインエラー
- hanakiアカウントでログイン不可
- エラー: "ユーザー名またはパスワードが違います"
- HTTPステータス: 401 Unauthorized

【症状2】データベース内容の消失
- admin_usersテーブル: hanakiユーザー消失、adminユーザーのみ存在
- membersテーブル: 全データ消失
- eventsテーブル: 全データ消失
- その他全テーブル: データ消失
```

### 1.3 タイムスタンプの矛盾
```
DBファイル作成日時: 2025-08-25 18:44:57
adminユーザー作成日時: 2025-08-17 22:44:38（1週間前）
→ 矛盾: 新しいDBファイルに古いデータが存在
```

### 1.4 影響範囲
- 会員データ: 全消失
- イベントデータ: 全消失
- 管理者アカウント: hanaki消失
- LINE連携情報: 全消失
- 出欠回答履歴: 全消失

## 2. 原因調査

### 2.1 調査内容
```bash
# 履歴確認
history | grep -E "(init-db|npm run|sqlite)"
→ 行142: docker compose exec api-server npm run init-db（過去に実行）

# DBファイル検索
find /opt/rcline -name "*.db" -type f
→ /opt/rcline/rcline.db のみ

# git管理確認
.gitignore確認 → rcline.dbは除外対象
git log確認 → DBファイルのコミット履歴なし
```

### 2.2 除外された原因
- **git操作**: DBファイルは.gitignoreで除外されているため関係なし
- **自動初期化**: Dockerfile、index.jsにinit-db自動実行なし
- **定期処理**: cronジョブなし

## 3. 想定される原因

### 3.1 最も可能性が高い原因
**DB停止中のファイル操作またはスクリプト実行**

理由：
- SQLiteの稼働中ファイルコピーは破損リスクが高い
- 今回破損していない = DB停止中の操作
- タイムスタンプがDockerリビルド時刻と一致

### 3.2 具体的なシナリオ
1. **シナリオA: Dockerリビルド時のボリューム再作成**
   - docker-compose.ymlの変更
   - ボリュームマウントパスの変更
   - 新規空DBファイル作成 → 古いバックアップからリストア

2. **シナリオB: 誤ったinit-db実行**
   - Dockerコンテナ再作成時
   - 何らかのスクリプトから間接的に実行
   - ただし、adminユーザーのタイムスタンプが古いため矛盾

3. **シナリオC: ファイルシステムレベルでの復元**
   - VPSのスナップショット復元
   - バックアップファイルの自動復元
   - ファイル作成日時と内容の不一致を説明可能

## 4. 対応策の検討

### 4.1 予防策
1. **DBバックアップ体制**
   - 停止時自動バックアップ
   - 定期バックアップ
   - 手動バックアップ

2. **危険操作の防止**
   - init-dbスクリプトの保護
   - 操作ログの記録
   - 重要コマンドのラッパースクリプト化

### 4.2 検知策
1. **監視**
   - DBファイルのタイムスタンプ監視
   - データ件数の定期チェック
   - ログ出力の強化

## 5. 実装した対策

### 5.1 バックアップ体制
```
backups/
├── rcline_stop_YYYYMMDD_HHMMSS.db    # 停止時バックアップ
├── rcline_manual_YYYYMMDD_HHMMSS.db  # 手動バックアップ
└── rcline_auto_YYYYMMDD_HHMMSS.db    # 定期バックアップ
```

### 5.2 運用スクリプト
```bash
# 1. Docker停止（自動バックアップ付き）
scripts/docker-stop.sh
- DBの自動バックアップ実行
- backups/rcline_stop_*.db として保存
- 実行ログ出力

# 2. Docker起動
scripts/docker-start.sh
- 通常起動処理
- 起動確認

# 3. 手動バックアップ
scripts/backup-db.sh
- オンラインバックアップ（稼働中実行可能）
- backups/rcline_manual_*.db として保存

# 4. 定期バックアップ（未稼働）
scripts/auto-backup.sh
- cron登録用（例: 0 2 * * *）
- 7日以上古い自動バックアップを自動削除
```

### 5.3 init-db保護機能
```javascript
// services/api-server/scripts/init-db.js
console.log('========================================');
console.log('       DB初期化スクリプト');
console.log('========================================');
console.log('実行日時:', new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }));
console.log('警告: このスクリプトは全データベースを削除して初期化します');
console.log('');
console.log('実行するには以下の手順に従ってください:');
console.log('1. このファイル内の "process.exit(1)" 行をコメントアウト');
console.log('2. スクリプトを再実行');
console.log('');
console.log('本番環境では絶対に実行しないでください！');
console.log('========================================');

// この行をコメントアウトして実行してください
process.exit(1);  // ← 安全装置
```

## 6. 今後の運用ルール

### 6.1 必須ルール
1. **Docker操作時**
   - 停止: 必ず `./scripts/docker-stop.sh` を使用
   - 起動: 必ず `./scripts/docker-start.sh` を使用
   - 直接 `docker compose down/up` は使用しない

2. **メンテナンス時**
   - 作業前に `./scripts/backup-db.sh` で手動バックアップ
   - 重要な変更後も手動バックアップ

3. **init-db使用禁止**
   - 本番環境では絶対に実行しない
   - 開発環境でも慎重に使用

### 6.2 推奨事項
1. **定期バックアップの有効化**（安定稼働後）
   ```bash
   # crontab -e
   0 2 * * * /opt/rcline/scripts/auto-backup.sh
   ```

2. **バックアップの外部保存**
   - 重要なバックアップは別サーバーにも保存
   - 定期的にローカルにダウンロード

3. **監視の実装**
   - DBサイズの急激な変化を検知
   - 会員数の異常な減少をアラート

## 7. 教訓

### 7.1 技術的教訓
- SQLiteは軽量だが、ファイルベースのため取り扱い注意
- Dockerボリュームの変更は慎重に
- タイムスタンプの矛盾は複数の操作が関与している可能性

### 7.2 運用的教訓
- 本番環境での破壊的操作は複数の安全装置が必要
- バックアップは「取る」だけでなく「復元テスト」も重要
- 原因不明でも、想定される原因への対策は有効

## 8. 参考情報

### 8.1 関連ファイル
- `/opt/rcline/rcline.db` - データベースファイル
- `/opt/rcline/backups/` - バックアップ格納フォルダ
- `/opt/rcline/scripts/` - 運用スクリプト群

### 8.2 復旧時のコマンド例
```bash
# バックアップから復旧
docker compose exec api-server sqlite3 /app/data/rcline.db ".restore /app/data/backup.db"

# 管理者アカウント再作成
docker compose exec api-server sqlite3 /app/data/rcline.db \
  "INSERT OR REPLACE INTO admin_users (id, username, password_hash, created_at, updated_at) \
   VALUES (2, 'hanaki', '\$2b\$10\$[hash]', datetime('now'), datetime('now'));"
```

## 9. 再発事例（2025-08-27）

### 9.1 発生状況
- **発生日時**: 2025-08-27 16:16頃（docker compose up -d --build実行時）
- **発見時刻**: 2025-08-27 16:34頃（LINE友だち追加テスト時）
- **発生環境**: VPS本番環境（/opt/rcline）

### 9.2 症状
```
【症状1】LINE自動紐づけ失敗
- followイベント処理は成功
- result: 'UNMATCHED'（会員データなし）

【症状2】データベース内容の再消失
- membersテーブル: 全データ消失
- eventsテーブル: 全データ消失
- admin_usersテーブル: adminユーザーのみ（hanaki消失）
```

### 9.3 直前の操作
1. `git reset --hard origin/main` で強制的にリモートの内容を反映
2. `docker compose up -d --build` でコンテナ再構築
3. この際、以下の警告が出力：
   ```
   WARN[0000] The "LINE_CHANNEL_SECRET" variable is not set...
   （その他環境変数の警告多数）
   ```

### 9.4 共通パターンの特定
**前回（8/25）との共通点**：
- gitから強制的に全ファイルを反映（reset --hard）
- docker-compose.ymlが開発環境用に置き換わる
- Caddyfileも開発環境用に置き換わる
- コンテナ再構築時にDB初期化が発生

### 9.5 根本原因
**gitリポジトリの設定ファイル管理構造**：
- `docker-compose.yml` → 開発用（ボリュームマウントなし）
- `docker-compose.vps.yml` → VPS本番用（別ファイルで管理）
- `caddy/Caddyfile` → 開発用（localhost設定）
- `caddy/Caddyfile.vps` → VPS本番用（別ファイルで管理）
- `.env.production` → gitignore対象

結果：`git reset --hard`実行時に設定ファイルが開発用に戻る

### 9.6 正しい復旧手順
```bash
# 1. DBバックアップから復旧
docker compose down
cp /opt/rcline/backups/rcline_stop_YYYYMMDD_HHMMSS.db /opt/rcline/rcline.db

# 2. VPS用設定ファイルをコピー
cp docker-compose.vps.yml docker-compose.yml
cp caddy/Caddyfile.vps caddy/Caddyfile

# 3. サービス再起動
docker compose up -d
```

### 9.7 防止策
1. **git操作後の必須作業**
   ```bash
   # git pull/reset後は必ず実行
   cp docker-compose.vps.yml docker-compose.yml
   cp caddy/Caddyfile.vps caddy/Caddyfile
   ```

2. **コンテナ再構築前の確認**
   ```bash
   # 環境変数警告が出た場合は設定ファイルを確認
   # 必要に応じて.env.productionも確認
   ```

### 9.8 追加の教訓
- **git reset --hard は設定ファイルを上書きする**
- **VPS用設定ファイルは別名で管理されている前提で運用**
- **バックアップのおかげで復旧は迅速に完了**

---
以上